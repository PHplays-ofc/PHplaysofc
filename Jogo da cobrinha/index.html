<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jogo da Cobrinha</title>
  <style>
    :root {
      --bg: #0f1226;
      --panel: #171b34;
      --accent: #6cf56c;
      --accent-2: #86a7ff;
      --grid: #23284e;
      --snake: #a5ff9e;
      --food: #ff6c6c;
      --text: #e7ecff;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 70% -10%, #1a1f44 0%, var(--bg) 60%);
      color: var(--text);
      display: grid;
      place-items: center;
    }

    .wrap {
      width: min(92vw, 820px);
      display: grid;
      gap: 14px;
    }

    header {
      display: grid;
      grid-template-columns: 1fr auto auto;
      align-items: center;
      gap: 10px;
    }

    h1 {
      margin: 0;
      font-size: clamp(20px, 2.6vw, 28px);
      letter-spacing: .5px;
      font-weight: 700;
    }

    .pill {
      background: var(--panel);
      border: 1px solid #20264d;
      border-radius: 14px;
      padding: 8px 12px;
      box-shadow: var(--shadow);
      display: inline-flex;
      gap: 10px;
      align-items: center;
      font-weight: 600;
      min-width: 120px;
      justify-content: center;
    }

    .pill b { color: var(--accent); }

    .board {
      position: relative;
      aspect-ratio: 1 / 1;
      background: repeating-linear-gradient(0deg, var(--grid) 0 2px, transparent 2px 40px),
                  repeating-linear-gradient(90deg, var(--grid) 0 2px, transparent 2px 40px);
      background-color: #0e1331;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid #232a59;
      box-shadow: var(--shadow);
      touch-action: none; /* para gestos */
    }

    canvas { width: 100%; height: 100%; display: block; }

    .hud {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    .modal {
      background: rgba(15,18,38,.86);
      border: 1px solid #2b336a;
      border-radius: 16px;
      padding: 18px 18px 16px;
      text-align: center;
      max-width: 85%;
      box-shadow: var(--shadow);
    }

    .modal h2 { margin: 0 0 8px; font-size: 22px; }
    .modal p { margin: 6px 0; opacity: .9; }

    .btns { display: flex; gap: 10px; justify-content: center; margin-top: 12px; }
    button {
      background: linear-gradient(180deg, #26306b, #1b214b);
      color: var(--text);
      border: 1px solid #38439a;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 700;
      letter-spacing: .3px;
      cursor: pointer;
      box-shadow: var(--shadow);
      transition: transform .08s ease;
    }
    button:active { transform: translateY(1px) scale(.98); }

    .kbd {
      display: inline-grid;
      grid-auto-flow: column;
      gap: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      opacity: .9;
    }
    .kbd span {
      border: 1px solid #38439a;
      background: #141a3a;
      padding: 2px 6px;
      border-radius: 6px;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(3, 64px);
      grid-template-rows: repeat(3, 64px);
      gap: 10px;
      justify-content: center;
      margin: 6px auto 0;
      filter: drop-shadow(0 6px 18px rgba(0,0,0,.35));
      user-select: none;
    }
    .controls button { width: 64px; height: 64px; border-radius: 14px; font-weight: 900; }
    .controls button:disabled { opacity: .35; }

    footer { opacity: .85; font-size: 13px; text-align: center; }
    a { color: var(--accent-2); text-decoration: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üêç Jogo da Cobrinha</h1>
      <div class="pill" id="score">Pontua√ß√£o: <b>0</b></div>
      <div class="pill" id="best">Recorde: <b>0</b></div>
    </header>

    <main class="board" id="board">
      <canvas id="game" width="600" height="600" aria-label="Tabuleiro do jogo da cobrinha"></canvas>
      <div class="hud" id="hud" aria-live="polite"></div>
    </main>

    <div class="controls" aria-label="Controles t√°teis">
      <button id="up">‚ñ≤</button>
      <button disabled></button>
      <button id="right">‚ñ∫</button>
      <button disabled></button>
      <button disabled></button>
      <button disabled></button>
      <button id="left">‚óÑ</button>
      <button id="down">‚ñº</button>
      <button id="pause">‚èØ</button>
    </div>

    <footer>
      Use as setas / WASD ‚Ä¢ <span class="kbd"><span>P</span><span>‚éµ</span></span> pausa ‚Ä¢ <span class="kbd"><span>R</span></span> reinicia
    </footer>
  </div>

  <script>
    // ===== Configura√ß√£o =====
    const CELL = 30; // tamanho de cada c√©lula (px)
    const GRID = 20; // 20x20 c√©lulas ‚Üí canvas 600x600
    const START_SPEED = 7; // c√©lulas por segundo
    const SPEED_STEP_FOOD = 5; // acelera a cada 5 comidas
    const SPEED_INC = 0.8; // +0.8 cps por passo

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');
    const scoreEl = document.querySelector('#score b');
    const bestEl = document.querySelector('#best b');
    const board = document.getElementById('board');

    const btnUp = document.getElementById('up');
    const btnDown = document.getElementById('down');
    const btnLeft = document.getElementById('left');
    const btnRight = document.getElementById('right');
    const btnPause = document.getElementById('pause');

    let rafId = null;
    let running = false;
    let paused = false;
    let lastTime = 0;
    let acc = 0; // acumulador de tempo

    const bestKey = 'snake_best_v1';
    let best = Number(localStorage.getItem(bestKey) || 0);
    bestEl.textContent = best;

    // Estado do jogo
    let state = {};

    function newGame() {
      state = {
        dir: {x: 1, y: 0}, // come√ßa indo para a direita
        nextDir: {x: 1, y: 0},
        snake: [ {x: 8, y: 10}, {x: 7, y: 10}, {x: 6, y: 10} ],
        food: spawnFood([]),
        score: 0,
        speed: START_SPEED,
        eaten: 0,
        over: false
      };
      scoreEl.textContent = 0;
      draw();
      showStart();
    }

    function spawnFood(blocked) {
      while (true) {
        const x = Math.floor(Math.random() * GRID);
        const y = Math.floor(Math.random() * GRID);
        if (!blocked.some(p => p.x === x && p.y === y)) return {x, y};
      }
    }

    function showStart() {
      hud.innerHTML = `
        <div class="modal" role="dialog" aria-label="Tela inicial">
          <h2>Pronto para jogar?</h2>
          <p>Coma a ma√ß√£ (<b style="color: var(--food)">‚ñ†</b>) e cres√ßa sem bater nas paredes ou em si mesmo.</p>
          <p>Controles: setas/WASD ‚Ä¢ <span class="kbd"><span>P</span><span>‚éµ</span></span> pausa ‚Ä¢ <span class="kbd"><span>R</span></span> reinicia.</p>
          <div class="btns"><button onclick="start()">Come√ßar</button></div>
        </div>`;
    }

    function showPause() {
      hud.innerHTML = `
        <div class="modal"><h2>Jogo pausado</h2>
        <p>Pressione <span class="kbd"><span>P</span><span>‚éµ</span></span> ou toque em ‚èØ para continuar.</p></div>`;
    }

    function showGameOver() {
      hud.innerHTML = `
        <div class="modal" role="dialog" aria-label="Fim de jogo">
          <h2>Game Over</h2>
          <p>Pontua√ß√£o: <b>${state.score}</b>${state.score > best ? ' ‚Ä¢ üéâ Novo recorde!' : ''}</p>
          <div class="btns">
            <button onclick="start()">Jogar de novo</button>
            <button onclick="newGame()">Menu</button>
          </div>
        </div>`;
    }

    function start() {
      if (running) cancelAnimationFrame(rafId);
      hud.innerHTML = '';
      running = true;
      paused = false;
      lastTime = performance.now();
      acc = 0;
      loop(lastTime);
    }

    function pauseToggle() {
      if (!running || state.over) return;
      paused = !paused;
      if (paused) {
        showPause();
      } else {
        hud.innerHTML = '';
        lastTime = performance.now();
        acc = 0;
        loop(lastTime);
      }
    }

    function loop(t) {
      rafId = requestAnimationFrame(loop);
      const dt = (t - lastTime) / 1000; // em segundos
      lastTime = t;
      if (paused) return;
      acc += dt;
      const step = 1 / state.speed; // tempo por c√©lula
      while (acc >= step) {
        update();
        acc -= step;
      }
      draw();
    }

    function update() {
      // aplicar dire√ß√£o escolhida, impedindo revers√£o instant√¢nea
      const nd = state.nextDir;
      if (!(nd.x === -state.dir.x && nd.y === -state.dir.y)) {
        state.dir = nd;
      }

      const head = state.snake[0];
      const nx = head.x + state.dir.x;
      const ny = head.y + state.dir.y;

      // colis√£o com parede
      if (nx < 0 || ny < 0 || nx >= GRID || ny >= GRID) {
        return gameOver();
      }

      // colis√£o com o pr√≥prio corpo
      if (state.snake.some((p, i) => i !== 0 && p.x === nx && p.y === ny)) {
        return gameOver();
      }

      // mover
      state.snake.unshift({x: nx, y: ny});

      // comer?
      if (nx === state.food.x && ny === state.food.y) {
        state.score += 10;
        state.eaten += 1;
        scoreEl.textContent = state.score;
        // acelera periodicamente
        if (state.eaten % SPEED_STEP_FOOD === 0) {
          state.speed += SPEED_INC;
        }
        // nova comida em c√©lula livre
        state.food = spawnFood(state.snake);
      } else {
        // n√£o comeu: remove cauda
        state.snake.pop();
      }
    }

    function gameOver() {
      running = false;
      state.over = true;
      cancelAnimationFrame(rafId);
      if (state.score > best) {
        best = state.score;
        localStorage.setItem(bestKey, best);
        bestEl.textContent = best;
      }
      showGameOver();
    }

    // ===== Renderiza√ß√£o =====
    function drawCell(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * CELL + 2, y * CELL + 2, CELL - 4, CELL - 4);
    }

    function draw() {
      // fundo suave
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // comida
      drawCell(state.food.x, state.food.y, getFoodColor());

      // cobra
      state.snake.forEach((p, i) => {
        const col = i === 0 ? '#d3ffd0' : 'var(--snake)';
        drawCell(p.x, p.y, i === 0 ? '#c2ffc6' : getSnakeColor(i));
      });

      // cabe√ßa com "olhinhos"
      const head = state.snake[0];
      if (head) {
        ctx.fillStyle = '#0a0f24';
        const cx = head.x * CELL + CELL / 2;
        const cy = head.y * CELL + CELL / 2;
        ctx.beginPath();
        ctx.arc(cx - 6, cy - 4, 2.5, 0, Math.PI * 2);
        ctx.arc(cx + 6, cy - 4, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function getSnakeColor(i){
      // leve gradiente por segmento
      const t = i / Math.max(1, state.snake.length - 1);
      const g = Math.floor(160 + 60 * (1 - t));
      return `rgb(${165}, ${g}, ${158})`;
    }

    function getFoodColor(){
      // pulsar leve
      const t = (performance.now() / 1000) % 1;
      const a = 0.6 + 0.4 * Math.sin(t * Math.PI * 2);
      return `rgba(255, 108, 108, ${a.toFixed(2)})`;
    }

    // ===== Entradas =====
    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (k === 'arrowup' || k === 'w') setDir(0, -1);
      else if (k === 'arrowdown' || k === 's') setDir(0, 1);
      else if (k === 'arrowleft' || k === 'a') setDir(-1, 0);
      else if (k === 'arrowright' || k === 'd') setDir(1, 0);
      else if (k === 'p' || k === ' ') { e.preventDefault(); pauseToggle(); }
      else if (k === 'r') { newGame(); start(); }
    });

    function setDir(x, y){
      state.nextDir = {x, y};
    }

    // Bot√µes t√°teis
    btnUp.addEventListener('click', () => setDir(0, -1));
    btnDown.addEventListener('click', () => setDir(0, 1));
    btnLeft.addEventListener('click', () => setDir(-1, 0));
    btnRight.addEventListener('click', () => setDir(1, 0));
    btnPause.addEventListener('click', () => pauseToggle());

    // Gestos (arrastar / swipe)
    let touchStart = null;
    board.addEventListener('pointerdown', (e) => {
      board.setPointerCapture(e.pointerId);
      touchStart = {x: e.clientX, y: e.clientY};
    });
    board.addEventListener('pointerup', (e) => {
      if (!touchStart) return;
      const dx = e.clientX - touchStart.x;
      const dy = e.clientY - touchStart.y;
      const ax = Math.abs(dx), ay = Math.abs(dy);
      if (Math.max(ax, ay) > 20){
        if (ax > ay) setDir(Math.sign(dx), 0); else setDir(0, Math.sign(dy));
      }
      touchStart = null;
    });

    // inicializa
    newGame();
  </script>
</body>
</html>
